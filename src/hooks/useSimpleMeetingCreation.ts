import { useState, useRef } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "@/lib/auth";
import { useToast } from "@/hooks/use-toast";
import { MeetingService } from "@/services/meetingService";
import { AudioProcessingService } from "@/services/audioProcessingService";
import { MeetingCreationData } from "@/types/meeting";
import { supabase } from "@/integrations/supabase/client";

export const useSimpleMeetingCreation = () => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isComplete, setIsComplete] = useState(false);
  const isMountedRef = useRef(true);
  
  const navigate = useNavigate();
  const { user } = useAuth();
  const { toast } = useToast();

  console.log('[useSimpleMeetingCreation] Hook initialized, current user:', user);

  const createMeeting = async (
    title: string,
    audioBlob: Blob | null,
    audioFile: File | null,
    participants: MeetingCreationData['participants'],
    selectedParticipantIds: string[]
  ) => {
    console.log('[useSimpleMeetingCreation] ========== STARTING MEETING CREATION ==========');
    console.log('[useSimpleMeetingCreation] Input received:', { 
      title: title?.trim() || 'EMPTY', 
      hasAudioBlob: !!audioBlob,
      hasAudioFile: !!audioFile,
      participantCount: selectedParticipantIds.length,
      userId: user?.id || 'NO USER'
    });
    
    if (!user?.id) {
      console.error('[useSimpleMeetingCreation] CRITICAL ERROR: No user ID found');
      toast({
        title: "Erreur d'authentification",
        description: "Vous devez √™tre connect√© pour cr√©er une r√©union",
        variant: "destructive",
      });
      navigate("/login");
      return;
    }

    console.log('[useSimpleMeetingCreation] Setting isSubmitting to true');
    if (!isMountedRef.current) {
      console.log('[useSimpleMeetingCreation] Component unmounted, aborting');
      return;
    }
    
    setIsSubmitting(true);
    setIsComplete(false);

    const hasAudio = !!(audioBlob || audioFile);
    let meetingId: string | null = null;

    try {
      // Step 1: Create meeting in database
      console.log('[CREATE] Creating meeting in database');
      meetingId = await MeetingService.createMeeting(title.trim(), user.id);
      
      if (!meetingId) {
        throw new Error('Meeting creation failed - no ID returned');
      }
      
      console.log('[CREATE] ‚úÖ Meeting created:', meetingId);
      
      // Add participants
      if (selectedParticipantIds.length > 0) {
        console.log('[CREATE] Adding participants:', selectedParticipantIds);
        await MeetingService.addParticipants(meetingId, selectedParticipantIds);
        console.log('[CREATE] ‚úÖ Participants added');
      }

      // Step 2: Process audio if provided and listen for task completion
      if (hasAudio) {
        console.log('[AUDIO] Processing audio - Setting up task completion listener');
        
        try {
          // Upload audio
          const audioFileUrl = await AudioProcessingService.uploadAudio(audioBlob, audioFile);
          console.log('[UPLOAD] ‚úÖ Audio uploaded');
          
          if (!isMountedRef.current) {
            console.log('[UPLOAD] Component unmounted during upload');
            return;
          }
          
          // Save audio URL
          await AudioProcessingService.saveAudioUrl(meetingId, audioFileUrl);
          console.log('[UPLOAD] ‚úÖ Audio URL saved');

          // Transcribe audio
          const participantCount = Math.max(selectedParticipantIds.length, 2);
          const transcript = await AudioProcessingService.transcribeAudio(
            audioFileUrl, 
            participantCount, 
            meetingId
          );
          
          console.log('[TRANSCRIBE] ‚úÖ Transcription completed');
          
          if (!isMountedRef.current) {
            console.log('[TRANSCRIBE] Component unmounted during transcription');
            return;
          }
          
          // Set up Realtime listener for task completion BEFORE starting AI processing
          console.log('[REALTIME] üîó Setting up task completion listener for meeting:', meetingId);
          
          const taskCompletionPromise = new Promise<boolean>((resolve) => {
            let processedTasks = new Set<string>();
            let totalTasksFound = false;
            let expectedTaskCount = 0;
            
            // Setup Realtime subscription for todos table updates
            const channel = supabase
              .channel(`task-completion-${meetingId}`)
              .on(
                'postgres_changes',
                {
                  event: '*',
                  schema: 'public',
                  table: 'todos',
                  filter: `meeting_id=eq.${meetingId}`
                },
                async (payload) => {
                  console.log('[REALTIME] üìã Task event detected:', {
                    event: payload.eventType,
                    taskId: payload.new?.id || payload.old?.id,
                    aiRecommendationGenerated: payload.new?.ai_recommendation_generated
                  });
                  
                  if (payload.eventType === 'INSERT') {
                    // Nouvelle t√¢che cr√©√©e
                    expectedTaskCount++;
                    console.log('[REALTIME] ‚ûï Nouvelle t√¢che cr√©√©e, total attendu:', expectedTaskCount);
                  } else if (payload.eventType === 'UPDATE' && payload.new?.ai_recommendation_generated === true) {
                    // T√¢che trait√©e
                    const taskId = payload.new.id;
                    processedTasks.add(taskId);
                    console.log('[REALTIME] ‚úÖ T√¢che trait√©e:', taskId, `(${processedTasks.size}/${expectedTaskCount})`);
                    
                    // V√©rifier si toutes les t√¢ches sont trait√©es
                    if (totalTasksFound && processedTasks.size >= expectedTaskCount && expectedTaskCount > 0) {
                      console.log('[REALTIME] üéØ Toutes les t√¢ches sont trait√©es! Redirection dans 3 secondes...');
                      setTimeout(() => {
                        console.log('[REALTIME] ‚úÖ Redirection apr√®s traitement complet des t√¢ches');
                        channel.unsubscribe();
                        resolve(true);
                      }, 3000);
                    }
                  }
                }
              )
              .subscribe((status) => {
                console.log('[REALTIME] Subscription status:', status);
              });

            // Marquer que la phase de cr√©ation des t√¢ches est termin√©e apr√®s 10 secondes
            setTimeout(() => {
              totalTasksFound = true;
              console.log('[REALTIME] üìù Phase de cr√©ation des t√¢ches termin√©e, t√¢ches attendues:', expectedTaskCount);
              
              // Si aucune t√¢che cr√©√©e, rediriger imm√©diatement
              if (expectedTaskCount === 0) {
                console.log('[REALTIME] ‚ö†Ô∏è Aucune t√¢che cr√©√©e, redirection imm√©diate');
                channel.unsubscribe();
                resolve(false);
              }
              // Si toutes les t√¢ches sont d√©j√† trait√©es, rediriger
              else if (processedTasks.size >= expectedTaskCount) {
                console.log('[REALTIME] ‚úÖ Toutes les t√¢ches d√©j√† trait√©es');
                channel.unsubscribe();
                resolve(true);
              }
            }, 10000);

            // Check if component unmounted
            const checkUnmounted = setInterval(() => {
              if (!isMountedRef.current) {
                console.log('[REALTIME] Component unmounted, cleaning up listener');
                clearInterval(checkUnmounted);
                channel.unsubscribe();
                resolve(false);
              }
            }, 1000);
          });

          // Start AI processing
          const selectedParticipants = participants.filter(p => 
            selectedParticipantIds.includes(p.id)
          );

          console.log('[PROCESS] Starting AI processing...');
          
          // Don't await this - let it run in background while we listen for task completion
          AudioProcessingService.processTranscriptWithAI(
            transcript,
            selectedParticipants,
            meetingId
          ).then(result => {
            console.log('[PROCESS] ‚úÖ AI processing completed:', result);
          }).catch(error => {
            console.error('[PROCESS] ‚ùå AI processing error:', error);
          });

          // Wait for task completion to be detected (no timeout)
          console.log('[REALTIME] üîÑ Waiting for task completion...');
          const hasCompletedTasks = await taskCompletionPromise;
          
          if (!isMountedRef.current) {
            console.log('[REALTIME] Component unmounted during wait');
            return;
          }

          if (hasCompletedTasks) {
            console.log('[SUCCESS] ‚úÖ Toutes les t√¢ches ont √©t√© trait√©es');
          } else {
            console.log('[WARNING] ‚ö†Ô∏è Attente interrompue');
          }
          
        } catch (audioError) {
          console.error('[AUDIO] Audio processing failed:', audioError);
          // Don't throw here, meeting was created successfully
          toast({
            title: "R√©union cr√©√©e",
            description: "La r√©union a √©t√© cr√©√©e mais le traitement audio a √©chou√©",
          });
        }
      }

      console.log('[SUCCESS] ========== MEETING CREATION COMPLETED ==========');

      // Redirection apr√®s traitement complet
      if (isMountedRef.current) {
        console.log('[SUCCESS] Setting isComplete to true');
        setIsComplete(true);
        
        // Message personnalis√©
        let description = "Votre r√©union a √©t√© cr√©√©e avec succ√®s";
        if (hasAudio) {
          description = "Votre r√©union a √©t√© cr√©√©e et toutes les t√¢ches ont √©t√© trait√©es";
        }
        
        toast({
          title: "R√©union cr√©√©e",
          description,
        });

        console.log('[SUCCESS] Redirection vers la r√©union:', meetingId);
        navigate(`/meetings/${meetingId}`);
      }

    } catch (error: any) {
      console.error("[ERROR] Meeting creation error:", error);
      
      if (meetingId) {
        // Meeting was created, still redirect
        console.log('[ERROR] Meeting created, navigating despite errors');
        if (isMountedRef.current) {
          setIsComplete(true);
          toast({
            title: "R√©union cr√©√©e",
            description: "La r√©union a √©t√© cr√©√©e avec succ√®s",
          });
          navigate(`/meetings/${meetingId}`);
        }
      } else {
        // Complete failure
        console.error('[ERROR] Complete failure - meeting not created');
        toast({
          title: "Erreur de cr√©ation",
          description: error.message || "Veuillez r√©essayer",
          variant: "destructive",
        });
        
        if (isMountedRef.current) {
          setIsSubmitting(false);
          setIsComplete(false);
        }
      }
    }
  };

  const resetMeetingCreation = () => {
    console.log('[useSimpleMeetingCreation] resetMeetingCreation called, isSubmitting:', isSubmitting);
    if (!isSubmitting && isMountedRef.current) {
      setIsSubmitting(false);
      setIsComplete(false);
    }
  };

  const cleanupOnUnmount = () => {
    console.log('[useSimpleMeetingCreation] cleanupOnUnmount called');
    isMountedRef.current = false;
  };

  return {
    isSubmitting,
    isComplete,
    createMeeting,
    resetMeetingCreation,
    cleanupOnUnmount
  };
};
