
import { createSupabaseClient } from './database-service.ts'
import { callOpenAI } from './openai-service.ts'

export async function processTasksWithRecommendations(
  cleanedTranscript: string, 
  meetingData: any,
  participants: any[]
) {
  if (!cleanedTranscript || cleanedTranscript.trim().length === 0) {
    console.log('‚ö° [UNIFIED-TODO-SERVICE] Aucun transcript √† traiter');
    return { processed: 0, successful: 0, failed: 0, fullyCompleted: true };
  }

  console.log(`‚ö° [UNIFIED-TODO-SERVICE] D√âBUT g√©n√©ration UNIFI√âE todos + recommandations avec GPT-4.1`);
  
  const supabaseClient = createSupabaseClient();
  const openaiApiKey = Deno.env.get('OPENAI_API_KEY');
  
  if (!openaiApiKey) {
    throw new Error('OpenAI API key not configured');
  }

  try {
    const participantNames = participants?.map(p => p.name).join(', ') || '';

    // Prompt unifi√© qui combine la cr√©ation de todos et les recommandations
    const unifiedPrompt = `Bas√© sur ce transcript de r√©union, identifie et REGROUPE INTELLIGEMMENT toutes les t√¢ches, actions et suivis par SUJETS COH√âRENTS pour √©viter les doublons. Privil√©gie le regroupement pour minimiser le nombre de t√¢ches.

Participants disponibles dans le syst√®me : ${participantNames}

**R√àGLES DE REGROUPEMENT OBLIGATOIRES:**
- Regroupe toutes les actions li√©es au M√äME SUJET/FOURNISSEUR/OUTIL en UNE SEULE t√¢che
- Une t√¢che = un sujet principal avec TOUT le contexte n√©cessaire
- √âvite absolument les doublons (ex: "contacter X" et "appeler X" = 1 seule t√¢che)
- Regroupe les actions s√©quentielles (ex: "demander devis" + "comparer prix" + "n√©gocier" = 1 t√¢che compl√®te)
- Privil√©gie les macro-t√¢ches sur les micro-actions

**R√àGLES DE CONTEXTE ENRICHI:**
- Inclus TOUT le contexte n√©cessaire pour comprendre et ex√©cuter la t√¢che
- Mentionne les d√©tails techniques, budg√©taires ou logistiques discut√©s
- Inclus les raisons/motivations derri√®re chaque action
- Sp√©cifie les d√©lais, √©ch√©ances ou priorit√©s mentionn√©es
- Sois concis mais avec tout le contexte n√©cessaire pour √™tre autonome
- ne pas mentionner le nom de la personne qui doit executer la tache mais plutot ce qui doit etre fait

**R√àGLES D'ASSIGNATION STRICTES:**
- Utilise SEULEMENT les noms EXACTS de cette liste : ${participantNames}
- Variantes accept√©es pour correspondance :
  ‚Ä¢ Le√Øla / leila / Leila
  ‚Ä¢ √âmilie / emilie / Emilie  
  ‚Ä¢ David / david / David Tabibian
  ‚Ä¢ Parmice / parmice / Parmis
  ‚Ä¢ Sybil / sybil
  ‚Ä¢ Tabibian / tabibian
- Si une personne dit "je vais faire X" ‚Üí assigne √† cette personne
- Si plusieurs personnes impliqu√©es ‚Üí assigne √† la personne principale
- Si aucune assignation claire, laisse "assigned_to" √† null

**R√àGLES POUR LES RECOMMANDATIONS IA:**
Pour chaque t√¢che, g√©n√®re:
1. **Recommandation d√©taill√©e** qui propose un plan d'ex√©cution, signale les points d'attention, sugg√®re des prestataires/outils, ou challenge les d√©cisions si pertinent.
2. **Email pr√©-r√©dig√© COMPLET** si communication n√©cessaire (interne: direct et concis / externe: professionnel avec contexte et tr√®s d√©taill√©s).
3. Si la t√¢che est simple/√©vidente, marque hasRecommendation: false avec "Aucune recommandation n√©cessaire."

Crit√®res qualit√© pour les recommandations:
- Concis, structur√©, actionnable
- Valeur ajout√©e r√©elle pour le cabinet d'ophtalmologie Dr Tabibian √† Gen√®ve
- Pas d'invention de contacts
- √âviter banalit√©s

CONTEXTE R√âUNION:
- Titre: ${meetingData.title || 'R√©union'}
- Date: ${meetingData.created_at || new Date().toISOString()}
- Participants: ${participantNames}

Transcript :
${cleanedTranscript}

IMPORTANT: Retourne UNIQUEMENT un JSON valide avec cette structure exacte :
{
  "tasks": [
    {
      "description": "Action principale + contexte complet concis mais d√©taill√©",
      "assigned_to": ["Nom exact du participant tel qu'il appara√Æt dans la liste"] ou null,
      "hasRecommendation": true/false,
      "recommendation": "Recommandation d√©taill√©e ou 'Aucune recommandation n√©cessaire.'",
      "emailDraft": "Email COMPLET (optionnel)" ou null
    }
  ]
}`;

    console.log(`üöÄ [UNIFIED-TODO-SERVICE] Traitement UNIFI√â avec GPT-4.1`);
    
    const callStartTime = Date.now();
    const unifiedResponse = await callOpenAI(unifiedPrompt, openaiApiKey, 0.3, 'gpt-4.1-2025-04-14', 3, 16384);
    const callDuration = Date.now() - callStartTime;
    
    console.log(`‚è±Ô∏è [UNIFIED-TODO-SERVICE] Appel unifi√© termin√© (${callDuration}ms)`);

    // Parser la r√©ponse
    let tasksWithRecommendations = [];
    try {
      console.log('üìÑ [UNIFIED-TODO-SERVICE] Raw response length:', unifiedResponse?.length || 0);
      
      // Nettoyer la r√©ponse avant de parser
      const cleanedResponse = unifiedResponse.trim()
        .replace(/^```json\s*/i, '')
        .replace(/^```\s*/i, '')
        .replace(/\s*```\s*$/i, '');
      
      const parsedData = JSON.parse(cleanedResponse);
      tasksWithRecommendations = parsedData.tasks || [];
      console.log(`üìã [UNIFIED-TODO-SERVICE] Parsed ${tasksWithRecommendations.length} tasks avec recommandations`);
    } catch (parseError) {
      console.error('‚ùå [UNIFIED-TODO-SERVICE] Error parsing JSON:', parseError);
      console.log('üìÑ [UNIFIED-TODO-SERVICE] Raw response:', unifiedResponse);
      throw new Error('Failed to parse unified response');
    }

    // Sauvegarder les t√¢ches ET les recommandations simultan√©ment
    let totalSuccessful = 0;
    let totalFailed = 0;
    let savedTasks = [];

    console.log(`üíæ [UNIFIED-TODO-SERVICE] Sauvegarde de ${tasksWithRecommendations.length} t√¢ches avec recommandations`);

    for (let i = 0; i < tasksWithRecommendations.length; i++) {
      const taskData = tasksWithRecommendations[i];
      try {
        console.log(`üíæ [UNIFIED-TODO-SERVICE] Sauvegarde t√¢che ${i+1}/${tasksWithRecommendations.length}: ${taskData.description?.substring(0, 50)}...`);
        
        // 1. Cr√©er la t√¢che d'abord
        const savedTask = await saveTaskUnified(supabaseClient, taskData, meetingData.id, participants);
        
        if (savedTask) {
          savedTasks.push(savedTask);
          
          // 2. Cr√©er la recommandation imm√©diatement apr√®s
          if (taskData.hasRecommendation !== false && taskData.recommendation) {
            const { error: recError } = await supabaseClient
              .from('todo_ai_recommendations')
              .insert({
                todo_id: savedTask.id,
                recommendation_text: taskData.recommendation,
                email_draft: taskData.emailDraft || null
              });
            
            if (recError) {
              console.error(`‚ùå [UNIFIED-TODO-SERVICE] Erreur sauvegarde recommandation pour t√¢che ${savedTask.id}:`, recError);
            } else {
              console.log(`‚úÖ [UNIFIED-TODO-SERVICE] Recommandation sauvegard√©e pour t√¢che ${savedTask.id}`);
            }
          }
          
          // 3. Marquer comme trait√©
          await supabaseClient
            .from('todos')
            .update({ ai_recommendation_generated: true })
            .eq('id', savedTask.id);
          
          totalSuccessful++;
          console.log(`‚úÖ [UNIFIED-TODO-SERVICE] T√¢che ${i+1} sauvegard√©e avec succ√®s avec ID: ${savedTask.id}`);
        }
        
      } catch (error) {
        console.error(`‚ùå [UNIFIED-TODO-SERVICE] Erreur sauvegarde t√¢che ${i+1}:`, error);
        totalFailed++;
      }
    }
    
    console.log(`üèÅ [UNIFIED-TODO-SERVICE] Traitement unifi√© termin√©: ${totalSuccessful} succ√®s, ${totalFailed} √©checs sur ${tasksWithRecommendations.length} t√¢ches`);
    
    return {
      processed: tasksWithRecommendations.length,
      successful: totalSuccessful,
      failed: totalFailed,
      fullyCompleted: true,
      savedTasks: savedTasks,
      unified: true,
      model: 'gpt-4.1-2025-04-14'
    };
    
  } catch (error) {
    console.error('‚ùå [UNIFIED-TODO-SERVICE] Erreur g√©n√©rale:', error);
    return { 
      processed: 0, 
      successful: 0, 
      failed: 0,
      fullyCompleted: false,
      error: error.message,
      unified: true
    };
  }
}

// Fonction pour sauvegarder une t√¢che (r√©utilise la logique existante)
async function saveTaskUnified(supabaseClient: any, task: any, meetingId: string, meetingParticipants: any[]) {
  console.log('üíæ Saving unified task:', task.description?.substring(0, 50) + '...');
  
  try {
    // R√©cup√©rer TOUS les participants de la base de donn√©es
    const { data: allParticipants, error: participantsError } = await supabaseClient
      .from('participants')
      .select('id, name, email')
      .order('name');

    if (participantsError) {
      console.error('‚ùå Error fetching all participants:', participantsError);
      throw participantsError;
    }

    // Cr√©er la t√¢che
    const { data: savedTask, error } = await supabaseClient
      .from('todos')
      .insert([{
        meeting_id: meetingId,
        description: task.description,
        status: 'confirmed',
        due_date: task.due_date || null,
        assigned_to: null
      }])
      .select()
      .single()

    if (error) {
      console.error('‚ùå Error saving unified task:', error)
      throw error
    }

    console.log('‚úÖ Unified task saved with ID:', savedTask.id)

    // Traiter les assignations
    let firstAssignedParticipantId = null;
    
    if (task.assigned_to && Array.isArray(task.assigned_to) && task.assigned_to.length > 0) {
      for (const participantName of task.assigned_to) {
        if (!participantName || typeof participantName !== 'string') continue;
        
        const participant = findBestParticipantMatch(participantName.toString(), allParticipants || []);
        
        if (participant) {
          const { error: assignError } = await supabaseClient
            .from('todo_participants')
            .insert([{
              todo_id: savedTask.id,
              participant_id: participant.id
            }])
          
          if (assignError) {
            console.error('‚ùå Error assigning participant:', assignError)
          } else {
            console.log('‚úÖ Participant assign√©:', participant.name, 'to unified task:', savedTask.id)
            
            if (!firstAssignedParticipantId) {
              firstAssignedParticipantId = participant.id;
            }
          }
        }
      }
    }

    // Mettre √† jour la colonne assigned_to
    if (firstAssignedParticipantId) {
      const { error: updateError } = await supabaseClient
        .from('todos')
        .update({ assigned_to: firstAssignedParticipantId })
        .eq('id', savedTask.id);
        
      if (updateError) {
        console.error('‚ùå Error updating assigned_to column:', updateError);
      } else {
        savedTask.assigned_to = firstAssignedParticipantId;
      }
    }

    return savedTask
  } catch (error) {
    console.error('‚ùå Error in saveTaskUnified:', error)
    throw error
  }
}

// Fonction helper pour trouver le participant (reprise de database-service.ts)
function findBestParticipantMatch(searchName: string, allParticipants: any[]): any | null {
  if (!searchName || !allParticipants?.length) return null;

  const normalizeParticipantName = (name: string): string => {
    return name
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .trim();
  };

  const getNameVariants = (searchName: string): string[] => {
    const normalized = normalizeParticipantName(searchName);
    
    const nameMapping: Record<string, string[]> = {
      'leila': ['le√Øla', 'leila'],
      'emilie': ['√©milie', 'emilie'],
      'david': ['david', 'david tabibian'],
      'parmice': ['parmice', 'parmis'],
      'sybil': ['sybil'],
      'tabibian': ['tabibian', 'dr tabibian', 'docteur tabibian']
    };
    
    for (const [key, variants] of Object.entries(nameMapping)) {
      if (variants.some(variant => normalizeParticipantName(variant) === normalized)) {
        return variants;
      }
    }
    
    return [searchName];
  };

  const variants = getNameVariants(searchName);
  
  for (const variant of variants) {
    const normalizedVariant = normalizeParticipantName(variant);
    
    for (const participant of allParticipants) {
      const normalizedParticipantName = normalizeParticipantName(participant.name);
      const normalizedEmail = normalizeParticipantName(participant.email?.split('@')[0] || '');
      
      if (normalizedParticipantName === normalizedVariant || 
          normalizedEmail === normalizedVariant ||
          normalizedParticipantName.includes(normalizedVariant) ||
          normalizedVariant.includes(normalizedParticipantName)) {
        return participant;
      }
    }
  }
  
  const firstName = normalizeParticipantName(searchName.split(' ')[0]);
  for (const participant of allParticipants) {
    const participantFirstName = normalizeParticipantName(participant.name.split(' ')[0]);
    if (participantFirstName === firstName) {
      return participant;
    }
  }
  
  return null;
}
