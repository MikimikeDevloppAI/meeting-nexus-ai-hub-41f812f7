export class SynthesisAgent {
  private apiKey: string;

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async synthesizeResponse(
    userMessage: string,
    conversationHistory: any[],
    databaseContext: any,
    embeddingsResult: any,
    internetContext: any,
    analysis: any,
    taskContext: any,
    meetingPreparationResult: any = null
  ): Promise<string> {
    console.log('[SYNTHESIS] üè• Synth√®se INTELLIGENTE Cabinet Dr Tabibian');

    const isReferencingPrevious = this.detectReferencePattern(userMessage);
    const isContinuation = conversationHistory.length > 0 && this.detectContinuation(userMessage);
    const contextInfo = this.analyzeContextType(userMessage, conversationHistory);
    const previousSubject = this.extractPreviousSubject(conversationHistory);

    console.log(`[SYNTHESIS] üß† Analyse du contexte APPROFONDIE: ${JSON.stringify({
      isReferencingPrevious,
      isContinuation,
      context: contextInfo.context,
      continuationType: contextInfo.continuationType,
      previousSubject
    })}`);

    console.log(`[SYNTHESIS] üéØ Sujet principal d√©tect√©: ${previousSubject}`);

    const conversationContext = this.formatConversationHistory(conversationHistory);
    console.log('[SYNTHESIS] üìú Formatage de l\'historique pour continuit√© MAXIMALE');

    let contextBuilder = '';
    let primarySource = 'general';

    if (embeddingsResult?.chunks?.length > 0) {
      console.log('[SYNTHESIS] üéØ Utilisation des donn√©es embeddings disponibles');
      primarySource = 'embeddings';
      
      const embeddingsContext = embeddingsResult.chunks.slice(0, 10).map((chunk: any, index: number) => {
        return `Document: ${chunk.document_name || 'Inconnu'}\nContenu: ${chunk.chunk_text}`;
      }).join('\n\n---\n\n');
      
      contextBuilder += `CONTEXTE DOCUMENTS VECTORIS√âS:\n${embeddingsContext}\n\n`;
    }

    if (databaseContext?.meetings?.length > 0 || databaseContext?.todos?.length > 0 || databaseContext?.participants?.length > 0) {
      console.log('[SYNTHESIS] üóÑÔ∏è Utilisation des donn√©es base de donn√©es');
      
      if (databaseContext.meetings?.length > 0) {
        const meetingsContext = databaseContext.meetings.slice(0, 5).map((meeting: any) => {
          return `R√©union: ${meeting.title}\nR√©sum√©: ${meeting.summary || 'Pas de r√©sum√©'}\nDate: ${meeting.created_at}`;
        }).join('\n\n---\n\n');
        contextBuilder += `CONTEXTE R√âUNIONS:\n${meetingsContext}\n\n`;
      }

      if (databaseContext.todos?.length > 0) {
        const todosContext = databaseContext.todos.slice(0, 8).map((todo: any) => {
          const participants = todo.participants?.map((tp: any) => tp.participant?.name).join(', ') || 'Aucun';
          return `T√¢che: ${todo.description}\nStatut: ${todo.status}\nParticipants: ${participants}\nDate: ${todo.created_at}`;
        }).join('\n\n---\n\n');
        contextBuilder += `CONTEXTE T√ÇCHES:\n${todosContext}\n\n`;
      }

      if (databaseContext.participants?.length > 0) {
        const participantsContext = databaseContext.participants.slice(0, 5).map((participant: any) => {
          return `Participant: ${participant.name}\nEmail: ${participant.email}`;
        }).join('\n\n---\n\n');
        contextBuilder += `CONTEXTE PARTICIPANTS:\n${participantsContext}\n\n`;
      }
    }

    // NOUVEAU : Int√©gration des r√©sultats de pr√©paration de r√©union
    if (meetingPreparationResult) {
      console.log('[SYNTHESIS] üìù Int√©gration r√©sultats pr√©paration r√©union');
      
      let preparationContext = `GESTION PR√âPARATION R√âUNION:\n`;
      preparationContext += `Action effectu√©e: ${meetingPreparationResult.action}\n`;
      preparationContext += `Succ√®s: ${meetingPreparationResult.success}\n`;
      preparationContext += `Message: ${meetingPreparationResult.message}\n`;
      
      if (meetingPreparationResult.points?.length > 0) {
        preparationContext += `\nPOINTS ACTUELS DE L'ORDRE DU JOUR (${meetingPreparationResult.points.length}):\n`;
        meetingPreparationResult.points.forEach((point: any, index: number) => {
          const creatorName = point.users?.name || 'Utilisateur inconnu';
          preparationContext += `${index + 1}. ${point.point_text} (ajout√© par ${creatorName})\n`;
        });
      } else {
        preparationContext += `\nAucun point dans l'ordre du jour actuellement.\n`;
      }
      
      contextBuilder += `${preparationContext}\n\n`;
    }

    if (taskContext?.currentTasks?.length > 0 || taskContext?.taskCreated) {
      console.log('[SYNTHESIS] üìã Utilisation des donn√©es t√¢ches');
      
      let tasksContext = 'CONTEXTE GESTION T√ÇCHES:\n';
      if (taskContext.taskCreated) {
        tasksContext += `Nouvelle t√¢che cr√©√©e: ${taskContext.taskCreated}\n`;
      }
      if (taskContext.currentTasks?.length > 0) {
        tasksContext += `T√¢ches pertinentes trouv√©es: ${taskContext.currentTasks.length}\n`;
        taskContext.currentTasks.slice(0, 5).forEach((task: any, index: number) => {
          tasksContext += `${index + 1}. ${task.description} (${task.status})\n`;
        });
      }
      contextBuilder += `${tasksContext}\n\n`;
    }

    console.log('[SYNTHESIS] üöÄ Envoi du prompt enrichi avec contexte RENFORC√â');

    const prompt = `Tu es OphtaCare, l'assistant IA sp√©cialis√© du cabinet d'ophtalmologie Dr Tabibian √† Gen√®ve.

R√îLE ET EXPERTISE :
- Tu es l'assistant principal du cabinet d'ophtalmologie Dr Tabibian
- Tu connais parfaitement l'organisation, les participants, les t√¢ches et les documents du cabinet
- Tu peux g√©rer les t√¢ches, consulter les documents et aider √† la pr√©paration des r√©unions
- Tu as acc√®s aux transcripts des r√©unions, aux t√¢ches en cours et aux documents du cabinet

CAPACIT√âS SP√âCIALES :
- Recherche dans les documents vectoris√©s du cabinet
- Gestion des t√¢ches (cr√©ation, suivi, attribution)
- Acc√®s aux informations des r√©unions et participants
- Gestion des points de pr√©paration de r√©union (ajout, suppression, liste)

GESTION DES POINTS DE PR√âPARATION DE R√âUNION :
- Si on te demande d'ajouter un point : confirme l'ajout et liste les points actuels
- Si on te demande de supprimer un point : confirme la suppression et explique ce qui reste
- Si on te demande la liste des points : pr√©sente-les de mani√®re claire et organis√©e
- Utilise des formats visuels avec des puces pour une meilleure lisibilit√©

HISTORIQUE DE CONVERSATION R√âCENT :
${conversationContext}

CONTEXTE DISPONIBLE :
${contextBuilder}

ANALYSE DE LA REQU√äTE :
- Type: ${analysis.queryType || 'g√©n√©ral'}
- Priorit√©: ${analysis.priority || 'g√©n√©rale'}
- R√©f√©rence pr√©c√©dente: ${isReferencingPrevious ? 'Oui' : 'Non'}
- Continuation: ${isContinuation ? 'Oui' : 'Non'}

INSTRUCTIONS :
1. R√©ponds de mani√®re naturelle et professionnelle
2. Utilise UNIQUEMENT les informations du contexte fourni
3. Si tu cr√©es une t√¢che, confirme sa cr√©ation
4. Si tu g√®res des points de r√©union, confirme l'action effectu√©e
5. Sois concis mais complet dans tes r√©ponses
6. Utilise un ton amical et professionnel

Question de l'utilisateur: "${userMessage}"

R√©ponds en tant qu'OphtaCare, l'assistant du cabinet Dr Tabibian :`;

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o',
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.7,
          max_tokens: 16384,
        }),
      });

      if (!response.ok) {
        throw new Error(`Erreur OpenAI: ${response.status}`);
      }

      const data = await response.json();
      let finalResponse = data.choices[0]?.message?.content || 'D√©sol√©, je n\'ai pas pu g√©n√©rer une r√©ponse appropri√©e.';

      // Nettoyage de la r√©ponse
      finalResponse = finalResponse
        .replace(/\[ACTION_TACHE:[^\]]*\]/gs, '')
        .replace(/\s*CONTEXT_PARTICIPANTS:.*$/gi, '')
        .replace(/\s*CONTEXT_UTILISATEURS:.*$/gi, '')
        .trim();

      console.log('[SYNTHESIS] ‚úÖ R√©ponse g√©n√©r√©e et nettoy√©e');
      return finalResponse;

    } catch (error) {
      console.error('[SYNTHESIS] ‚ùå Erreur lors de la synth√®se:', error);
      return 'Je rencontre actuellement un probl√®me technique. Pouvez-vous reformuler votre demande ?';
    }
  }

  private detectReferencePattern(userMessage: string): boolean {
    const lowerMessage = userMessage.toLowerCase().trim();
    
    // Mots cl√©s qui indiquent une r√©f√©rence au contexte pr√©c√©dent (RENFORC√âS)
    const referenceKeywords = [
      '√ßa', 'cela', 'cette', 'celui', 'celle', 'ceci', 'celui-ci', 'celle-ci',
      'la m√™me', 'le m√™me', 'les m√™mes', 'comme √ßa', 'pareille', 'similaire',
      'pour √ßa', 'avec √ßa', 'de √ßa', 'du premier', 'le premier', 'la premi√®re',
      'premier que', 'mentionn√©', 'dit', 'parl√©', '√©voqu√©', 'discut√©',
      'pr√©c√©dent', 'pr√©c√©dente', 'avant', 'tant√¥t', 'plus haut', 'ci-dessus'
    ];

    return referenceKeywords.some(keyword => lowerMessage.includes(keyword));
  }

  private detectContinuation(userMessage: string): boolean {
    const lowerMessage = userMessage.toLowerCase().trim();
    
    // Mots cl√©s pour continuit√© d'action (RENFORC√âS)
    const continuationKeywords = [
      'recherche sur internet', 'cherche sur internet', 'trouve sur internet',
      'recherche internet', 'cherche internet', 'trouve internet',
      'recherche sur le web', 'cherche sur le web', 'trouve sur le web',
      'recherche web', 'cherche web', 'trouve web',
      'recherche', 'cherche', 'trouve', 'contact', 'coordonn√©es',
      'site internet', 'site web', 'adresse internet', 'adresse web',
      'num√©ro', 't√©l√©phone', 'email', 'mail', 'informations',
      'pour moi', 'stp', 's\'il te pla√Æt', 'aide moi'
    ];

    return continuationKeywords.some(keyword => lowerMessage.includes(keyword));
  }

  private analyzeContextType(userMessage: string, conversationHistory: any[]): any {
    if (!conversationHistory || conversationHistory.length === 0) {
      return { 
        isReferencingPrevious: false, 
        isContinuation: false,
        context: '',
        continuationType: 'none',
        previousSubject: null
      };
    }

    const lowerMessage = userMessage.toLowerCase().trim();
    
    // Mots cl√©s qui indiquent une r√©f√©rence au contexte pr√©c√©dent (RENFORC√âS)
    const referenceKeywords = [
      '√ßa', 'cela', 'cette', 'celui', 'celle', 'ceci', 'celui-ci', 'celle-ci',
      'la m√™me', 'le m√™me', 'les m√™mes', 'comme √ßa', 'pareille', 'similaire',
      'pour √ßa', 'avec √ßa', 'de √ßa', 'du premier', 'le premier', 'la premi√®re',
      'premier que', 'mentionn√©', 'dit', 'parl√©', '√©voqu√©', 'discut√©',
      'pr√©c√©dent', 'pr√©c√©dente', 'avant', 'tant√¥t', 'plus haut', 'ci-dessus'
    ];

    // Mots cl√©s pour continuit√© d'action (RENFORC√âS)
    const continuationKeywords = [
      'recherche sur internet', 'cherche sur internet', 'trouve sur internet',
      'recherche internet', 'cherche internet', 'trouve internet',
      'recherche sur le web', 'cherche sur le web', 'trouve sur le web',
      'recherche web', 'cherche web', 'trouve web',
      'recherche', 'cherche', 'trouve', 'contact', 'coordonn√©es',
      'site internet', 'site web', 'adresse internet', 'adresse web',
      'num√©ro', 't√©l√©phone', 'email', 'mail', 'informations',
      'pour moi', 'stp', 's\'il te pla√Æt', 'aide moi'
    ];

    const isReferencingPrevious = referenceKeywords.some(keyword => lowerMessage.includes(keyword));
    const isContinuation = continuationKeywords.some(keyword => lowerMessage.includes(keyword));
    
    // Analyser les derniers messages pour extraire le contexte
    let previousSubject = null;
    let continuationType = 'none';
    let contextDescription = '';

    if (isReferencingPrevious || isContinuation) {
      // Chercher dans les 6 derniers messages pour identifier le sujet
      const recentMessages = conversationHistory.slice(-6);
      
      for (let i = recentMessages.length - 1; i >= 0; i--) {
        const msg = recentMessages[i];
        if (msg.isUser && msg.content.toLowerCase() !== lowerMessage) {
          const content = msg.content.toLowerCase();
          
          // Identifier des sujets sp√©cifiques avec plus de patterns
          if (content.includes('nespresso') || content.includes('caf√©')) {
            previousSubject = 'Nespresso Professionnel';
            contextDescription = 'R√©f√©rence √† la recherche de contacts Nespresso Professionnel';
            continuationType = 'contact_search';
            break;
          }
          if (content.includes('fontaine') && content.includes('eau')) {
            previousSubject = 'fontaine √† eau';
            contextDescription = 'R√©f√©rence √† la fontaine √† eau discut√©e pr√©c√©demment';
            continuationType = 'equipment_search';
            break;
          }
          if (content.includes('fournisseur') || content.includes('prestataire') || content.includes('entreprise')) {
            previousSubject = this.extractCompanyName(content) || 'fournisseur mentionn√© pr√©c√©demment';
            contextDescription = 'R√©f√©rence aux fournisseurs discut√©s pr√©c√©demment';
            continuationType = 'supplier_search';
            break;
          }
          if (content.includes('contact') || content.includes('coordonn√©es') || content.includes('trouve')) {
            // Extraire le sujet de la recherche de contact plus pr√©cis√©ment
            previousSubject = this.extractSearchSubject(content);
            contextDescription = 'R√©f√©rence √† une recherche de contact pr√©c√©dente';
            continuationType = 'contact_search';
            break;
          }
          // Nouveau: d√©tecter les noms de produits/services
          const productMatches = content.match(/(?:contact|trouve|cherche|recherche)\s+(?:moi\s+)?(?:les?\s+)?(?:contact|coordonn√©es|info|information)?\s*(?:de|pour|sur)?\s+([a-z√†-√ø\s]+)/i);
          if (productMatches && productMatches[1]) {
            previousSubject = productMatches[1].trim();
            contextDescription = `R√©f√©rence √† la recherche pour ${previousSubject}`;
            continuationType = 'product_search';
            break;
          }
        }
      }

      // Si c'est une demande de recherche internet sans sujet pr√©cis identifi√©
      if (isContinuation && (lowerMessage.includes('recherche') || lowerMessage.includes('web') || lowerMessage.includes('internet')) && !previousSubject) {
        // Chercher le dernier sujet mentionn√© dans la conversation
        for (let i = recentMessages.length - 1; i >= 0; i--) {
          const msg = recentMessages[i];
          if (msg.isUser) {
            // Extraire le sujet principal du message
            const extractedSubject = this.extractSearchSubject(msg.content);
            if (extractedSubject) {
              previousSubject = extractedSubject;
              contextDescription = 'Demande de recherche internet pour le sujet pr√©c√©dent';
              continuationType = 'internet_search';
              break;
            }
          }
        }
      }
    }

    return { 
      isReferencingPrevious,
      isContinuation,
      context: contextDescription,
      continuationType,
      previousSubject
    };
  }

  private extractPreviousSubject(conversationHistory: any[]): string | null {
    if (!conversationHistory || conversationHistory.length === 0) return null;

    // Analyser les 5 derniers messages pour extraire le sujet principal
    const recentMessages = conversationHistory.slice(-5);
    
    // Rechercher dans l'ordre inverse pour trouver le dernier sujet mentionn√©
    for (let i = recentMessages.length - 1; i >= 0; i--) {
      const msg = recentMessages[i];
      if (msg.isUser) {
        const subject = this.extractSearchSubject(msg.content);
        if (subject) {
          console.log(`[SYNTHESIS] üéØ Sujet extrait du message ${i}: "${subject}"`);
          return subject;
        }
      }
    }

    return null;
  }

  private extractSearchSubject(content: string): string | null {
    const lowerContent = content.toLowerCase();
    
    // Patterns pour extraire le sujet de recherche
    const patterns = [
      /(?:contact|trouve|cherche|recherche)\s+(?:moi\s+)?(?:les?\s+)?(?:contact|coordonn√©es|info|information)?\s*(?:de|pour|sur)?\s+([a-z√†-√ø\s]{3,30})/i,
      /(?:adresse|site|num√©ro|t√©l√©phone|email)\s+(?:de|pour|sur)?\s+([a-z√†-√ø\s]{3,30})/i,
      /([a-z√†-√ø\s]{3,30})\s+(?:professionnel|entreprise|soci√©t√©|contact|coordonn√©es)/i
    ];

    for (const pattern of patterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        let subject = match[1].trim();
        // Nettoyer le sujet extrait
        subject = subject.replace(/\b(les|des|pour|sur|avec|sans|dans|par)\b/gi, '').trim();
        if (subject.length > 2) {
          return subject;
        }
      }
    }

    return null;
  }

  private extractCompanyName(content: string): string | null {
    // Patterns pour extraire des noms d'entreprise
    const companyPatterns = [
      /([A-Z√Ä-≈∏][a-z√†-√ø]+(?:\s+[A-Z√Ä-≈∏][a-z√†-√ø]+)*)\s+(?:SA|SARL|AG|GmbH|S√†rl|Ltd|Inc|Corp)/i,
      /([A-Z√Ä-≈∏][a-z√†-√ø]+(?:\s+[A-Z√Ä-≈∏][a-z√†-√ø]+)*)\s+(?:professionnel|entreprise|soci√©t√©)/i
    ];

    for (const pattern of companyPatterns) {
      const match = content.match(pattern);
      if (match && match[1]) {
        return match[1].trim();
      }
    }

    return null;
  }

  private formatConversationHistory(conversationHistory: any[]): string {
    if (!conversationHistory || conversationHistory.length === 0) return '';

    let formattedHistory = '';
    conversationHistory.forEach((msg: any, index: number) => {
      const role = msg.isUser ? 'üë§ UTILISATEUR' : 'ü§ñ ASSISTANT';
      const timestamp = new Date(msg.timestamp).toLocaleTimeString('fr-FR', { 
        hour: '2-digit', 
        minute: '2-digit' 
      });
      formattedHistory += `[${index + 1}] ${role} [${timestamp}]: "${msg.content}"\n\n`;
    });

    return formattedHistory;
  }

  private getLastAssistantMessage(conversationHistory: any[]): string {
    if (!conversationHistory || conversationHistory.length === 0) return '';
    
    // Chercher le dernier message de l'assistant
    for (let i = conversationHistory.length - 1; i >= 0; i--) {
      const msg = conversationHistory[i];
      if (!msg.isUser) {
        return msg.content;
      }
    }
    return '';
  }

  private isShortResponseToQuestion(currentMessage: string, lastAssistantMessage: string): boolean {
    // V√©rifier si le message actuel est court (moins de 20 caract√®res)
    const isShort = currentMessage.trim().length < 20;
    
    // V√©rifier si le dernier message de l'assistant contenait une question
    const hasQuestion = lastAssistantMessage.includes('?') || 
                       lastAssistantMessage.toLowerCase().includes('qui') ||
                       lastAssistantMessage.toLowerCase().includes('comment') ||
                       lastAssistantMessage.toLowerCase().includes('assigner') ||
                       lastAssistantMessage.toLowerCase().includes('pr√©ciser') ||
                       lastAssistantMessage.toLowerCase().includes('quel') ||
                       lastAssistantMessage.toLowerCase().includes('quelle');
    
    return isShort && hasQuestion;
  }

  private async getAssignedName(assignedId: string | null): Promise<string | null> {
    if (!assignedId) return null;
    
    // Cette m√©thode devrait r√©cup√©rer le nom du participant depuis la base de donn√©es
    // Pour l'instant, on retourne l'ID - peut √™tre am√©lior√© plus tard
    return assignedId;
  }
}
