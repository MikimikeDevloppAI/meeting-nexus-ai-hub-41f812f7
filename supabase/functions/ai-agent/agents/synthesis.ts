export class SynthesisAgent {
  private openaiApiKey: string;

  constructor(openaiApiKey: string) {
    this.openaiApiKey = openaiApiKey;
  }

  async synthesizeResponse(
    originalQuery: string,
    conversationHistory: any[],
    databaseContext: any,
    embeddingContext: any,
    internetContext: any,
    analysis: any,
    taskContext: any
  ): Promise<string> {
    console.log('[SYNTHESIS] üè• Synth√®se INTELLIGENTE Cabinet Dr Tabibian');

    // PHASE 1: R√âPONSE BAS√âE SUR LA RECHERCHE VECTORIELLE UNIQUEMENT
    console.log('[SYNTHESIS] üéØ Phase 1: R√©ponse bas√©e sur recherche vectorielle');
    
    if (embeddingContext.chunks && embeddingContext.chunks.length > 0) {
      const vectorBasedResponse = await this.generateVectorBasedResponse(
        originalQuery, 
        embeddingContext, 
        analysis
      );
      
      // Si la r√©ponse vectorielle est satisfaisante, l'enrichir avec les d√©tails du meeting
      if (vectorBasedResponse && this.isResponseSatisfactory(vectorBasedResponse, originalQuery)) {
        console.log('[SYNTHESIS] ‚úÖ R√©ponse vectorielle satisfaisante, enrichissement avec d√©tails meeting');
        
        const enrichedResponse = await this.enrichWithMeetingDetails(
          vectorBasedResponse,
          originalQuery,
          databaseContext,
          embeddingContext,
          analysis
        );
        
        return this.finalizeResponse(enrichedResponse, analysis, embeddingContext, databaseContext);
      }
    }

    // PHASE 2: FALLBACK - SYNTH√àSE COMPL√àTE CLASSIQUE
    console.log('[SYNTHESIS] üîÑ Phase 2: Fallback synth√®se compl√®te');
    return this.generateFullSynthesis(originalQuery, conversationHistory, databaseContext, embeddingContext, internetContext, analysis, taskContext);
  }

  private async generateVectorBasedResponse(
    originalQuery: string,
    embeddingContext: any,
    analysis: any
  ): Promise<string> {
    const vectorPrompt = `Tu es l'assistant IA du cabinet d'ophtalmologie Dr Tabibian √† Gen√®ve.

MISSION PRIORITAIRE : R√©pondre directement √† partir des extraits de documents trouv√©s.

QUESTION : "${originalQuery}"

EXTRAITS PERTINENTS TROUV√âS DANS LES DONN√âES CABINET :
${embeddingContext.chunks.slice(0, 5).map((chunk: any, i: number) => 
  `${i+1}. [Similarit√©: ${(chunk.similarity * 100).toFixed(0)}%] ${chunk.chunk_text}`
).join('\n\n')}

INSTRUCTIONS :
- R√©ponds DIRECTEMENT √† la question en utilisant les extraits fournis
- Si la r√©ponse est dans les extraits, dis OUI et explique
- Si la r√©ponse n'est PAS dans les extraits, dis NON clairement
- Sois pr√©cis et factuel
- Cite les √©l√©ments pertinents trouv√©s
- N'invente rien qui n'est pas dans les extraits

R√âPONSE COURTE ET PR√âCISE :`;

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.openaiApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [{ role: 'user', content: vectorPrompt }],
          temperature: 0.1, // Tr√®s faible pour r√©ponses factuelles
          max_tokens: 500,
        }),
      });

      const data = await response.json();
      return data.choices[0]?.message?.content || '';
    } catch (error) {
      console.error('[SYNTHESIS] ‚ùå Erreur r√©ponse vectorielle:', error);
      return '';
    }
  }

  private isResponseSatisfactory(response: string, originalQuery: string): boolean {
    // V√©rifier si la r√©ponse contient des √©l√©ments positifs
    const positiveIndicators = ['oui', 'effectivement', 'dans', 'mentionn√©', 'parl√©', '√©voqu√©', 'discut√©'];
    const negativeIndicators = ['non', 'pas', 'aucun', 'introuvable', 'absent'];
    
    const lowerResponse = response.toLowerCase();
    const hasPositive = positiveIndicators.some(indicator => lowerResponse.includes(indicator));
    const hasNegative = negativeIndicators.some(indicator => lowerResponse.includes(indicator));
    
    // La r√©ponse est satisfaisante si elle est suffisamment longue et contient des √©l√©ments factuels
    return response.length > 50 && (hasPositive || !hasNegative);
  }

  private async enrichWithMeetingDetails(
    baseResponse: string,
    originalQuery: string,
    databaseContext: any,
    embeddingContext: any,
    analysis: any
  ): Promise<string> {
    console.log('[SYNTHESIS] üìã Enrichissement avec d√©tails meeting');

    // Identifier les meetings pertinents √† partir des chunks
    const relevantMeetings = this.extractRelevantMeetings(embeddingContext.chunks, databaseContext.meetings);
    
    if (relevantMeetings.length === 0) {
      return baseResponse;
    }

    const enrichmentPrompt = `Tu es l'assistant IA du cabinet d'ophtalmologie Dr Tabibian.

R√âPONSE DE BASE : 
${baseResponse}

D√âTAILS DES R√âUNIONS PERTINENTES :
${relevantMeetings.map((meeting: any, i: number) => `
${i+1}. R√âUNION: ${meeting.title} (${new Date(meeting.created_at).toLocaleDateString('fr-FR')})
   R√âSUM√â: ${meeting.summary || 'Pas de r√©sum√©'}
   ${meeting.transcript ? `TRANSCRIPT DISPONIBLE (${meeting.transcript.length} caract√®res)` : 'Pas de transcript'}
`).join('\n')}

MISSION : Enrichir la r√©ponse de base avec les d√©tails sp√©cifiques des r√©unions.

R√àGLES :
- Garde la r√©ponse de base comme fondation
- Ajoute les d√©tails pertinents des r√©unions (dates, contexte, participants)
- Si un transcript complet est demand√©, fournis-le
- Reste factuel et pr√©cis
- Mentionne les sources (quelle r√©union)

R√âPONSE ENRICHIE :`;

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.openaiApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [{ role: 'user', content: enrichmentPrompt }],
          temperature: 0.2,
          max_tokens: 1200,
        }),
      });

      const data = await response.json();
      return data.choices[0]?.message?.content || baseResponse;
    } catch (error) {
      console.error('[SYNTHESIS] ‚ùå Erreur enrichissement:', error);
      return baseResponse;
    }
  }

  private extractRelevantMeetings(chunks: any[], meetings: any[]): any[] {
    if (!chunks || !meetings) return [];
    
    // Extraire les meeting_ids des chunks
    const meetingIds = [...new Set(chunks
      .filter(chunk => chunk.meeting_id)
      .map(chunk => chunk.meeting_id)
    )];
    
    // Trouver les meetings correspondants
    return meetings.filter(meeting => meetingIds.includes(meeting.id));
  }

  private async generateFullSynthesis(
    originalQuery: string,
    conversationHistory: any[],
    databaseContext: any,
    embeddingContext: any,
    internetContext: any,
    analysis: any,
    taskContext: any
  ): Promise<string> {
    console.log('[SYNTHESIS] üè• Synth√®se INTELLIGENTE Cabinet Dr Tabibian');

    const contextSummary = this.buildIntelligentContextSummary(databaseContext, embeddingContext, internetContext, taskContext);
    const confidence = analysis.confidenceLevel || 0.7;
    
    let systemPrompt = `Tu es l'assistant IA SUPER-INTELLIGENT du cabinet d'ophtalmologie Dr Tabibian √† Gen√®ve.

MISSION CABINET M√âDICAL :
- Assistant administratif et m√©dical sp√©cialis√© en ophtalmologie
- Priorit√© ABSOLUE : Recherche s√©mantique dans les donn√©es internes AVANT tout enrichissement
- Acc√®s complet aux transcripts de r√©unions, documents, t√¢ches administratives
- Compr√©hension intelligente des r√©f√©rences temporelles (derni√®re r√©union, r√©union de juin, etc.)
- Enrichissement internet seulement apr√®s recherche interne

CONTEXTE CABINET DR TABIBIAN :
${contextSummary}

NIVEAU DE CONFIANCE : ${(confidence * 100).toFixed(0)}%

R√âF√âRENCES TEMPORELLES INTELLIGENTES :
${analysis.temporalReference ? `- R√©f√©rence d√©tect√©e: ${analysis.temporalReference.type} ${analysis.temporalReference.value || ''}` : '- Aucune r√©f√©rence temporelle sp√©cifique'}

R√àGLES DE R√âPONSE CABINET M√âDICAL :
1. **PRIORIT√â RECHERCHE S√âMANTIQUE** - Utilise d'abord les donn√©es internes trouv√©es
2. **COMPR√âHENSION TEMPORELLE** - Identifie correctement les r√©f√©rences aux r√©unions
3. **R√âPONSES COMPL√àTES** - Fournis toujours une r√©ponse utile, m√™me avec donn√©es limit√©es  
4. **CONTEXTE OPHTALMOLOGIE** - Maintiens l'expertise m√©dicale et le contexte genevois
5. **TRANSPARENCE SOURCES** - Indique clairement les sources utilis√©es (interne vs externe)
6. **ACC√àS TRANSCRIPTS** - Fournis les transcripts si demand√©s explicitement
7. **ACTIONS STRUCTUR√âES** - Utilise la syntaxe [ACTION_TACHE:...] pour les t√¢ches

SYNTAXE ACTIONS T√ÇCHES :
- [ACTION_TACHE:TYPE=create,description="Description pr√©cise",assigned_to="Nom personne"]
- [ACTION_TACHE:TYPE=update,id="ID",description="Nouvelle description"]
- [ACTION_TACHE:TYPE=complete,id="ID"]
- [ACTION_TACHE:TYPE=delete,id="ID"]

STYLE CABINET M√âDICAL :
- Professionnel et expert en ophtalmologie
- Contextualisation genevoise (CHF, syst√®me suisse)
- √âmojis m√©dicaux appropri√©s : üëÅÔ∏è üè• üìã üíä üîç üìÖ
- D√©monstration de compr√©hension du contexte cabinet`;

    // Enrichissement selon le type de requ√™te et contexte temporel
    if (analysis.queryType === 'meeting' && databaseContext.meetings?.length > 0) {
      systemPrompt += `\n\nCONTEXTE R√âUNIONS SP√âCIAL :
- ${databaseContext.meetings.length} r√©union(s) trouv√©e(s) dans les donn√©es cabinet
- Utilise les informations r√©elles des transcripts pour r√©pondre
- Sois pr√©cis sur les dates et contenus mentionn√©s
- Si transcript demand√© explicitement, fournis-le int√©gralement`;
    }

    if (analysis.temporalReference?.needs_database_lookup) {
      systemPrompt += `\n\nCONTEXTE TEMPOREL INTELLIGENT :
- R√©f√©rence temporelle d√©tect√©e: ${analysis.temporalReference.type}
- ${analysis.temporalReference.value ? `Valeur: ${analysis.temporalReference.value}` : ''}
- Utilise les donn√©es trouv√©es pour cette p√©riode sp√©cifique
- Explique quelle r√©union correspond √† la demande`;
    }

    if (analysis.queryType === 'task') {
      systemPrompt += `\n\nCONTEXTE T√ÇCHES ADMINISTRATIVES :
- L'utilisateur demande une gestion de t√¢ches cabinet
- G√©n√®re l'action appropri√©e avec la syntaxe [ACTION_TACHE:...]
- Confirme l'action dans ta r√©ponse`;
    }

    if (analysis.administrativeContext) {
      systemPrompt += `\n\nCONTEXTE ADMINISTRATIF CABINET :
- Focus sur la gestion administrative du cabinet Dr Tabibian
- Utilise les donn√©es internes en priorit√©
- Contextualise pour l'ophtalmologie genevoise`;
    }

    // Construction du contexte conversationnel intelligent
    const conversationContext = this.buildConversationContext(conversationHistory);
    
    // Construction du contexte de donn√©es enrichi
    const dataContext = this.buildDataContext(databaseContext, embeddingContext, internetContext);

    const userPrompt = `QUESTION UTILISATEUR : "${originalQuery}"

${conversationContext ? `CONTEXTE CONVERSATION :\n${conversationContext}\n` : ''}

${dataContext ? `DONN√âES CABINET DR TABIBIAN DISPONIBLES :\n${dataContext}\n` : ''}

${taskContext.hasTaskContext ? `
T√ÇCHES CABINET EN COURS (${taskContext.currentTasks.length}) :
${taskContext.currentTasks.slice(0, 10).map(task => `- ${task.description} (${task.status}) ${task.assigned_to ? `- Assign√©: ${task.assigned_to}` : ''}`).join('\n')}
` : ''}

INSTRUCTIONS INTELLIGENTES CABINET :
- R√©ponds directement et compl√®tement √† la question
- Utilise PRIORITAIREMENT les donn√©es internes du cabinet trouv√©es
- Si donn√©es limit√©es, fournis quand m√™me une r√©ponse utile
- Maintiens le contexte ophtalmologie cabinet Dr Tabibian Gen√®ve
- Sois pr√©cis sur les sources utilis√©es (donn√©es cabinet vs informations g√©n√©rales)
- Si transcript demand√©, fournis-le int√©gralement
- G√©n√®re les actions [ACTION_TACHE:...] si demand√©
- TOUJOURS donner une r√©ponse, m√™me si elle est partielle
- D√©montre ta compr√©hension du contexte temporel si applicable`;

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.openaiApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ],
          temperature: 0.2,
          max_tokens: 1500, // Plus de tokens pour r√©ponses compl√®tes avec transcripts
        }),
      });

      const data = await response.json();
      let finalResponse = data.choices[0]?.message?.content || 'D√©sol√©, je n\'ai pas pu traiter votre demande.';

      // Enrichissement intelligent de la r√©ponse
      finalResponse = this.enrichResponseWithContext(finalResponse, analysis, confidence, databaseContext, embeddingContext, internetContext);

      console.log('[SYNTHESIS] ‚úÖ R√©ponse cabinet m√©dical intelligente g√©n√©r√©e');
      return finalResponse;

    } catch (error) {
      console.error('[SYNTHESIS] ‚ùå Erreur:', error);
      
      // R√©ponse de fallback intelligente m√™me en cas d'erreur
      return this.generateIntelligentFallback(originalQuery, databaseContext, embeddingContext, taskContext);
    }
  }

  private finalizeResponse(response: string, analysis: any, embeddingContext: any, databaseContext: any): string {
    let finalizedResponse = response;

    // Ajout d'indicateurs de source
    if (embeddingContext.chunks?.length > 0) {
      finalizedResponse += `\n\nüîç *Bas√© sur ${embeddingContext.chunks.length} √©l√©ment(s) trouv√©(s) dans vos donn√©es cabinet.*`;
    }

    if (databaseContext.meetings?.length > 0) {
      finalizedResponse += `\n\nüìä *Sources: ${databaseContext.meetings.length} r√©union(s) de votre cabinet Dr Tabibian.*`;
    }

    return finalizedResponse;
  }

  private buildIntelligentContextSummary(databaseContext: any, embeddingContext: any, internetContext: any, taskContext: any): string {
    const parts = [];

    if (taskContext.hasTaskContext) {
      parts.push(`üìã T√¢ches cabinet: ${taskContext.currentTasks.length} en cours`);
    }

    if (databaseContext.meetings?.length > 0) {
      parts.push(`üè• R√©unions cabinet: ${databaseContext.meetings.length} trouv√©es`);
    }

    if (databaseContext.documents?.length > 0) {
      parts.push(`üìÅ Documents cabinet: ${databaseContext.documents.length} disponibles`);
    }

    if (embeddingContext.hasRelevantContext) {
      parts.push(`üéØ Donn√©es s√©mantiques: ${embeddingContext.chunks.length} √©l√©ments pertinents`);
    }

    if (internetContext.hasContent) {
      parts.push(`üåê Enrichissement: Informations compl√©mentaires disponibles`);
    }

    return parts.length > 0 ? parts.join(' | ') : 'Base de donn√©es cabinet Dr Tabibian disponible';
  }

  private buildConversationContext(conversationHistory: any[]): string {
    if (!conversationHistory || conversationHistory.length === 0) return '';
    
    const recentMessages = conversationHistory.slice(-6).map(msg => 
      `${msg.isUser ? 'üë§ Cabinet/√âquipe' : 'ü§ñ Assistant Dr Tabibian'}: ${msg.content.substring(0, 150)}${msg.content.length > 150 ? '...' : ''}`
    );
    
    return recentMessages.join('\n');
  }

  private buildDataContext(databaseContext: any, embeddingContext: any, internetContext: any): string {
    const dataParts = [];

    // Contexte des r√©unions avec d√©tails temporels
    if (databaseContext.meetings?.length > 0) {
      dataParts.push(`\nüè• R√âUNIONS CABINET TROUV√âES (${databaseContext.meetings.length}) :`);
      databaseContext.meetings.slice(0, 3).forEach((meeting: any, i: number) => {
        const meetingDate = meeting.created_at ? new Date(meeting.created_at).toLocaleDateString('fr-FR') : 'Date inconnue';
        dataParts.push(`  ${i+1}. ${meeting.title} - ${meetingDate}`);
        if (meeting.summary) {
          dataParts.push(`     R√©sum√©: ${meeting.summary.substring(0, 200)}${meeting.summary.length > 200 ? '...' : ''}`);
        }
        if (meeting.transcript) {
          dataParts.push(`     üìù Transcript disponible (${meeting.transcript.length} caract√®res)`);
        }
      });
    }

    // Contexte des chunks avec relevance
    if (embeddingContext.chunks?.length > 0) {
      dataParts.push(`\nüéØ CONTENU S√âMANTIQUE PERTINENT (${embeddingContext.chunks.length} √©l√©ments) :`);
      embeddingContext.chunks.slice(0, 3).forEach((chunk: any, i: number) => {
        dataParts.push(`  ${i+1}. ${chunk.chunk_text?.substring(0, 150)}${chunk.chunk_text?.length > 150 ? '...' : ''}`);
        if (chunk.similarity) {
          dataParts.push(`     (Pertinence: ${(chunk.similarity * 100).toFixed(0)}%)`);
        }
      });
    }

    // Contexte des documents cabinet
    if (databaseContext.documents?.length > 0) {
      dataParts.push(`\nüìÅ DOCUMENTS CABINET (${databaseContext.documents.length}) :`);
      databaseContext.documents.slice(0, 2).forEach((doc: any, i: number) => {
        dataParts.push(`  ${i+1}. ${doc.ai_generated_name || doc.original_name}`);
        if (doc.ai_summary) {
          dataParts.push(`     ${doc.ai_summary.substring(0, 100)}...`);
        }
      });
    }

    // Contexte enrichissement internet
    if (internetContext.hasContent) {
      dataParts.push(`\nüåê ENRICHISSEMENT EXTERNE :`);
      dataParts.push(`  Informations compl√©mentaires trouv√©es pour le contexte cabinet`);
    }

    return dataParts.join('\n');
  }

  private enrichResponseWithContext(
    response: string, 
    analysis: any, 
    confidence: number, 
    databaseContext: any, 
    embeddingContext: any, 
    internetContext: any
  ): string {
    let enrichedResponse = response;

    // Ajout d'indicateurs de confiance si n√©cessaire
    if (confidence < 0.5 && !response.includes('donn√©es limit√©es')) {
      enrichedResponse += '\n\nüí° *R√©ponse bas√©e sur des informations limit√©es du cabinet. Pour plus de pr√©cision, n\'h√©sitez pas √† me donner plus de contexte.*';
    }

    // Ajout de contexte source si pertinent
    if (databaseContext.meetings?.length > 0 && analysis.queryType === 'meeting') {
      enrichedResponse += `\n\nüìä *Bas√© sur ${databaseContext.meetings.length} r√©union(s) de votre cabinet Dr Tabibian.*`;
    }

    if (embeddingContext.chunks?.length > 0) {
      enrichedResponse += `\n\nüîç *Information trouv√©e dans ${embeddingContext.chunks.length} √©l√©ment(s) de vos donn√©es cabinet.*`;
    }

    if (internetContext.hasContent) {
      enrichedResponse += `\n\nüåê *Enrichi avec des informations externes compl√©mentaires.*`;
    }

    // Ajout contexte temporel si pertinent
    if (analysis.temporalReference?.needs_database_lookup && databaseContext.meetings?.length > 0) {
      enrichedResponse += `\n\nüìÖ *R√©union identifi√©e selon votre r√©f√©rence temporelle: ${analysis.temporalReference.type}.*`;
    }

    return enrichedResponse;
  }

  private generateIntelligentFallback(originalQuery: string, databaseContext: any, embeddingContext: any, taskContext: any): string {
    const hasData = databaseContext.meetings?.length > 0 || embeddingContext.chunks?.length > 0 || taskContext.hasTaskContext;
    
    if (hasData) {
      return `üè• Je rencontre un probl√®me technique temporaire, mais je vois que vous avez des donn√©es dans votre cabinet Dr Tabibian √† Gen√®ve. 

Concernant votre question "${originalQuery}", je peux vous confirmer que j'ai acc√®s √† :
${databaseContext.meetings?.length > 0 ? `- ${databaseContext.meetings.length} r√©union(s) r√©cente(s) avec transcripts` : ''}
${embeddingContext.chunks?.length > 0 ? `- ${embeddingContext.chunks.length} √©l√©ment(s) de contenu pertinent` : ''}
${taskContext.hasTaskContext ? `- ${taskContext.currentTasks.length} t√¢che(s) administratives en cours` : ''}

Pourriez-vous reformuler votre question ou √™tre plus sp√©cifique ? Je suis l√† pour vous aider avec votre cabinet d'ophtalmologie. üëÅÔ∏è`;
    }

    return `üè• Je suis l'assistant du cabinet Dr Tabibian √† Gen√®ve et je reste disponible pour vous aider malgr√© ce probl√®me technique temporaire.

Pour votre question "${originalQuery}", je peux vous assister avec :
- üìã Gestion des t√¢ches administratives et planning
- üîç Recherche dans vos donn√©es de cabinet (r√©unions, transcripts)
- üíä Conseils en ophtalmologie et gestion cabinet
- üìä Organisation administrative cabinet m√©dical
- üìÖ Acc√®s aux transcripts de r√©unions (derni√®re r√©union, r√©union de juin, etc.)

Pouvez-vous reformuler votre demande ou √™tre plus pr√©cis sur ce que vous cherchez ? üëÅÔ∏è`;
  }
}
