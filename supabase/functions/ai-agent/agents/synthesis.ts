export class SynthesisAgent {
  private openaiApiKey: string;

  constructor(openaiApiKey: string) {
    this.openaiApiKey = openaiApiKey;
  }

  async synthesizeResponse(
    originalMessage: string,
    conversationHistory: any[],
    databaseContext: any,
    embeddingContext: any,
    internetContext: any,
    galaxusContext: any,
    analysis: any,
    taskContext?: any // NOUVEAU param√®tre
  ): Promise<string> {
    console.log('[SYNTHESIS] Synth√®se INTELLIGENTE avec gestion T√ÇCHES');
    
    // Construction du contexte enrichi avec t√¢ches
    let contextualContent = this.buildEnrichedContext(
      databaseContext, 
      embeddingContext, 
      internetContext, 
      galaxusContext,
      taskContext // Inclure contexte t√¢ches
    );

    // Adaptation du prompt selon le type de requ√™te
    let synthesisPrompt = '';
    
    if (analysis.requiresTasks && taskContext?.hasTaskContext) {
      synthesisPrompt = this.buildTaskSpecializedPrompt(originalMessage, taskContext, contextualContent, analysis);
    } else {
      synthesisPrompt = this.buildGeneralPrompt(originalMessage, contextualContent, analysis);
    }

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.openaiApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: this.getSystemPrompt()
            },
            {
              role: 'user',
              content: synthesisPrompt
            }
          ],
          temperature: 0.3,
          max_tokens: 1500,
        }),
      });

      const data = await response.json();
      let finalResponse = data.choices[0]?.message?.content || "D√©sol√©, je n'ai pas pu traiter votre demande.";
      
      // Nettoyage de la r√©ponse
      finalResponse = this.cleanResponse(finalResponse);
      
      console.log('[SYNTHESIS] ‚úÖ R√©ponse intelligente g√©n√©r√©e');
      return finalResponse;
      
    } catch (error) {
      console.error('[SYNTHESIS] ‚ùå Erreur synth√®se:', error);
      return "D√©sol√©, je rencontre un probl√®me technique. Pouvez-vous r√©essayer ?";
    }
  }

  private buildTaskSpecializedPrompt(message: string, taskContext: any, contextualContent: string, analysis: any): string {
    let taskInfo = '';
    
    if (taskContext.taskCreated) {
      taskInfo += `\nüéØ T√ÇCHE CR√â√âE AVEC SUCC√àS :
- ID: ${taskContext.taskCreated.id}
- Description: "${taskContext.taskCreated.description}"
- Statut: ${taskContext.taskCreated.status}
- Cr√©√©e le: ${new Date(taskContext.taskCreated.created_at).toLocaleString('fr-FR')}`;
    }

    if (taskContext.currentTasks.length > 0) {
      taskInfo += `\nüìã T√ÇCHES EN COURS (${taskContext.currentTasks.length}) :`;
      taskContext.currentTasks.slice(0, 10).forEach((task: any, index: number) => {
        const participants = task.participants?.map((tp: any) => tp.participant?.name).filter(Boolean).join(', ') || 'Non assign√©e';
        taskInfo += `\n${index + 1}. "${task.description}" - Statut: ${task.status} - Assign√©e √†: ${participants}`;
      });
    }

    return `DEMANDE SP√âCIALIS√âE T√ÇCHES : "${message}"

ACTION D√âTECT√âE : ${analysis.taskAction || 'consultation'}

${taskInfo}

${contextualContent}

INSTRUCTIONS SP√âCIALIS√âES :
1. R√©pondre de mani√®re PR√âCISE et DIRECTE sur les t√¢ches
2. Si t√¢che cr√©√©e ‚Üí confirmer et donner d√©tails
3. Si consultation ‚Üí lister les t√¢ches pertinentes avec d√©tails
4. Proposer actions suivantes (assigner, modifier, compl√©ter)
5. Rester dans le contexte OphtaCare
6. NE PAS inventer d'informations
7. Format clair et organis√©

R√©ponse FOCALIS√âE T√ÇCHES :`;
  }

  private buildGeneralPrompt(message: string, contextualContent: string, analysis: any): string {
    return `DEMANDE UTILISATEUR : "${message}"

TYPE DE REQU√äTE : ${analysis.queryType}
PRIORIT√â : ${analysis.priority}

${contextualContent}

INSTRUCTIONS STRICTES :
1. R√©ponse PR√âCISE bas√©e UNIQUEMENT sur les donn√©es trouv√©es
2. NE JAMAIS inventer coordonn√©es, URLs, ou informations
3. Si pas d'information ‚Üí dire clairement "je n'ai pas trouv√©"
4. Mentionner TOUJOURS d'autres fournisseurs suisses si pertinent
5. Rester dans contexte m√©dical OphtaCare
6. Format markdown pour liens : [texte](url)

R√©ponse ENRICHIE :`;
  }

  private buildEnrichedContext(
    databaseContext: any, 
    embeddingContext: any, 
    internetContext: any, 
    galaxusContext: any,
    taskContext?: any
  ): string {
    let context = '';

    // Contexte t√¢ches (prioritaire)
    if (taskContext?.hasTaskContext) {
      context += `\nüéØ CONTEXTE T√ÇCHES OphtaCare :\n`;
      if (taskContext.taskCreated) {
        context += `- Nouvelle t√¢che cr√©√©e : "${taskContext.taskCreated.description}"\n`;
      }
      if (taskContext.currentTasks.length > 0) {
        context += `- ${taskContext.currentTasks.length} t√¢che(s) en cours dans le syst√®me\n`;
      }
    }

    // ... keep existing code (other context building)

    return context;
  }

  private getSystemPrompt(): string {
    return `Tu es l'assistant IA sp√©cialis√© OphtaCare pour le cabinet du Dr Tabibian √† Gen√®ve.

MISSION PRINCIPALE :
- Aider l'√©quipe administrative avec les t√¢ches quotidiennes
- G√©rer et cr√©er des t√¢ches efficacement
- Fournir des informations pr√©cises bas√©es sur les donn√©es internes
- Ne JAMAIS inventer d'informations

SP√âCIALISATION T√ÇCHES :
- Cr√©ation, consultation et gestion des t√¢ches
- Suivi des t√¢ches en cours et assignations
- Propositions d'actions concr√®tes

R√àGLES ABSOLUES :
1. Pr√©cision et fiabilit√© des informations
2. Pas d'invention de donn√©es
3. Focus sur l'aide pratique et concr√®te
4. Contexte m√©dical toujours respect√©

STYLE : Professionnel, pr√©cis, orient√© action.`;
  }

  private cleanResponse(response: string): string {
    return response
      .replace(/\s*CONTEXT_PARTICIPANTS:.*$/gi, '')
      .replace(/^\W+|\W+$/g, '')
      .trim();
  }

  private detectActionWithContext(query: string, conversationHistory: any[], databaseContext: any): any {
    const lowerQuery = query.toLowerCase();
    
    // D√©tection d'actions renforc√©e avec contexte
    const actionPatterns = {
      create: {
        patterns: ['cr√©e', 'cr√©er', 'ajoute', 'ajouter', 'nouvelle', 'nouveau', 'faire', 'organiser', 'planifier'],
        targets: ['t√¢che', 'task', 'todo', 'action', 'rendez-vous', 'r√©union', 'rappel']
      },
      update: {
        patterns: ['modifie', 'modifier', 'change', 'changer', 'update', 'mettre √† jour', 'corriger'],
        targets: ['t√¢che', 'information', 'statut', 'date', 'description']
      },
      help: {
        patterns: ['aide', 'explique', 'comment', 'montre', 'guide', 'assistance', 'conseille'],
        targets: ['proc√©dure', '√©tapes', 'm√©thode', 'utilisation', 'fonctionnement']
      },
      search: {
        patterns: ['trouve', 'cherche', 'recherche', 'montre', 'affiche', 'o√π est'],
        targets: ['information', 'document', 'personne', 't√¢che', 'r√©union']
      }
    };
    
    let detectedAction = null;
    let confidence = 0;
    
    for (const [actionType, config] of Object.entries(actionPatterns)) {
      const patternMatch = config.patterns.some(pattern => lowerQuery.includes(pattern));
      const targetMatch = config.targets.some(target => lowerQuery.includes(target));
      
      if (patternMatch && (targetMatch || actionType === 'help' || actionType === 'search')) {
        const currentConfidence = patternMatch && targetMatch ? 1.0 : 0.7;
        if (currentConfidence > confidence) {
          confidence = currentConfidence;
          detectedAction = {
            type: actionType,
            confidence,
            details: this.extractActionDetails(query, actionType, databaseContext)
          };
        }
      }
    }
    
    // D√©tection sp√©ciale pour t√¢ches avec participants
    if (detectedAction?.type === 'create' && lowerQuery.includes('t√¢che')) {
      detectedAction.details = this.extractTaskCreationDetailsEnhanced(query, databaseContext);
    }
    
    return {
      isAction: detectedAction !== null,
      action: detectedAction,
      confidence
    };
  }

  private extractActionDetails(query: string, actionType: string, databaseContext: any): any {
    const details: any = { originalQuery: query };
    
    switch (actionType) {
      case 'create':
        if (query.toLowerCase().includes('t√¢che')) {
          details.taskCreation = this.extractTaskCreationDetailsEnhanced(query, databaseContext);
        }
        break;
        
      case 'help':
        details.helpType = 'procedural';
        details.context = 'medical_administrative';
        break;
        
      case 'search':
        details.searchTarget = this.identifySearchTarget(query);
        break;
    }
    
    return details;
  }

  private extractTaskCreationDetailsEnhanced(query: string, databaseContext: any): any {
    const lowerQuery = query.toLowerCase();
    
    // Extraction de la description avec patterns am√©lior√©s
    let description = query;
    const actionPrefixes = [
      'cr√©e une t√¢che', 'cr√©er une t√¢che', 'ajoute une t√¢che', 'nouvelle t√¢che',
      'je vais cr√©er', 'peux-tu cr√©er', 'fait une t√¢che', 't√¢che pour'
    ];
    
    actionPrefixes.forEach(prefix => {
      if (lowerQuery.includes(prefix)) {
        const index = lowerQuery.indexOf(prefix);
        description = query.substring(index + prefix.length).trim();
      }
    });
    
    // Nettoyage de la description
    description = description.replace(/^[:;,\s]+/, '').trim();
    
    // Extraction d'assignation avec matching intelligent sur participants
    let assignedTo = null;
    const participants = databaseContext.participants || [];
    
    // Patterns d'assignation √©tendus
    const assignmentPatterns = [
      /(?:pour|√†|assign√©[e]?\s+√†|responsable\s*:)\s+([a-z√°√†√¢√§√©√®√™√´√≠√¨√Æ√Ø√≥√≤√¥√∂√∫√π√ª√º√ß\s]+)/gi,
      /(?:demande[r]?\s+√†|dis\s+√†|dit\s+√†)\s+([a-z√°√†√¢√§√©√®√™√´√≠√¨√Æ√Ø√≥√≤√¥√∂√∫√π√ª√º√ß\s]+)/gi,
      /([a-z√°√†√¢√§√©√®√™√´√≠√¨√Æ√Ø√≥√≤√¥√∂√∫√π√ª√º√ß]+)\s+(?:doit|va|peut|should)/gi
    ];
    
    for (const pattern of assignmentPatterns) {
      const matches = [...query.matchAll(pattern)];
      for (const match of matches) {
        const nameCandidate = match[1].trim();
        
        // Matching avec participants existants (fuzzy)
        const foundParticipant = participants.find(p => {
          const pName = p.name.toLowerCase();
          const candidate = nameCandidate.toLowerCase();
          return pName.includes(candidate) || 
                 candidate.includes(pName) ||
                 this.fuzzyNameMatch(pName, candidate);
        });
        
        if (foundParticipant) {
          assignedTo = foundParticipant.name;
          description = description.replace(new RegExp(match[0], 'gi'), '').trim();
          break;
        } else if (nameCandidate.length > 2 && /^[a-z√°√†√¢√§√©√®√™√´√≠√¨√Æ√Ø√≥√≤√¥√∂√∫√π√ª√º√ß\s]+$/i.test(nameCandidate)) {
          assignedTo = nameCandidate;
          description = description.replace(new RegExp(match[0], 'gi'), '').trim();
        }
      }
      if (assignedTo) break;
    }
    
    // Extraction de date d'√©ch√©ance
    let dueDate = null;
    const datePatterns = [
      /(avant le|pour le|d'ici le|√©ch√©ance|deadline)\s*:?\s*([0-9\/\-\.]+)/i,
      /(demain|aujourd'hui|cette semaine|semaine prochaine)/i
    ];
    
    for (const pattern of datePatterns) {
      const match = query.match(pattern);
      if (match) {
        dueDate = match[2] || match[1];
        description = description.replace(match[0], '').trim();
        break;
      }
    }
    
    // Actions sp√©cifiques d√©tect√©es
    const actionTypes = {
      'acheter': /(?:achat|acheter|commander)\s+(?:de\s+|des?\s+)?([^.!?\n]+)/i,
      'contacter': /contacter\s+([^.!?\n]+)/i,
      'v√©rifier': /v√©rifier\s+([^.!?\n]+)/i,
      'pr√©parer': /pr√©parer\s+([^.!?\n]+)/i,
      'organiser': /organiser\s+([^.!?\n]+)/i,
      'programmer': /programmer\s+([^.!?\n]+)/i
    };
    
    let actionType = 'g√©n√©ral';
    for (const [type, pattern] of Object.entries(actionTypes)) {
      const match = query.match(pattern);
      if (match) {
        actionType = type;
        if (!description || description.length < 10) {
          description = `${type.charAt(0).toUpperCase() + type.slice(1)} ${match[1].trim()}`;
        }
        break;
      }
    }
    
    // Nettoyage final
    description = description
      .replace(/CONTEXT_PARTICIPANTS:.*$/gi, '')
      .replace(/^\W+|\W+$/g, '')
      .trim();
    
    if (!description || description.length < 3) {
      description = 'Nouvelle t√¢che √† d√©finir';
    }
    
    return {
      type: 'create',
      data: {
        description,
        assigned_to: assignedTo,
        due_date: dueDate,
        action_type: actionType,
        context: 'medical_administrative'
      }
    };
  }

  private fuzzyNameMatch(name1: string, name2: string): boolean {
    const words1 = name1.split(/\s+/);
    const words2 = name2.split(/\s+/);
    
    return words1.some(w1 => 
      words2.some(w2 => 
        Math.abs(w1.length - w2.length) <= 2 && 
        (w1.includes(w2) || w2.includes(w1) || this.levenshteinDistance(w1, w2) <= 2)
      )
    );
  }

  private levenshteinDistance(str1: string, str2: string): number {
    const matrix = [];
    for (let i = 0; i <= str2.length; i++) matrix[i] = [i];
    for (let j = 0; j <= str1.length; j++) matrix[0][j] = j;
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }

  private identifySearchTarget(query: string): string {
    const targets = {
      'document': ['document', 'fichier', 'pdf', 'rapport'],
      'person': ['personne', 'patient', 'docteur', 'coll√®gue', 'participant'],
      'task': ['t√¢che', 'todo', 'action', 'travail'],
      'meeting': ['r√©union', 'meeting', 'rendez-vous', 'consultation'],
      'information': ['info', 'information', 'd√©tail', 'donn√©e']
    };
    
    const lowerQuery = query.toLowerCase();
    for (const [target, keywords] of Object.entries(targets)) {
      if (keywords.some(keyword => lowerQuery.includes(keyword))) {
        return target;
      }
    }
    
    return 'general';
  }

  private buildUltraEnrichedContext(databaseContext: any, embeddingContext: any, internetContext: any, galaxusContext: any, analysis: any): any {
    const enriched = {
      // Donn√©es de base
      meetings: databaseContext.meetings || [],
      documents: databaseContext.documents || [],
      todos: databaseContext.todos || [],
      participants: databaseContext.participants || [],
      chunks: embeddingContext.chunks || [],
      sources: embeddingContext.sources || [],
      
      // Enrichissements
      fuzzyMatches: databaseContext.fuzzyMatches || [],
      targetedExtracts: databaseContext.targetedExtracts || null,
      internetContent: internetContext.content || '',
      internetSources: internetContext.sources || [],
      
      // Nouvelles donn√©es Galaxus avec validation
      galaxusProducts: galaxusContext?.products || [],
      galaxusRecommendations: galaxusContext?.recommendations || '',
      hasGalaxusProducts: galaxusContext?.hasProducts || false,
      hasValidatedGalaxusLinks: galaxusContext?.products?.some((p: any) => p.validated) || false,
      
      // Validation des coordonn√©es Internet
      hasValidatedContacts: internetContext.contactValidation?.hasValidatedContacts || false,
      contactConfidenceScore: internetContext.contactValidation?.confidenceScore || 0,
      validatedContacts: internetContext.contactValidation?.foundContacts || [],
      
      // M√©triques de qualit√©
      hasEmbeddingContext: embeddingContext.hasRelevantContext || false,
      hasInternetContext: internetContext.hasContent || false,
      searchQuality: {
        embeddingIterations: embeddingContext.searchIterations || 0,
        expansionLevel: embeddingContext.expansionLevel || 0,
        chunksFound: embeddingContext.chunks?.length || 0,
        totalDataPoints: (databaseContext.meetings?.length || 0) + 
                        (databaseContext.documents?.length || 0) + 
                        (databaseContext.todos?.length || 0) + 
                        (embeddingContext.chunks?.length || 0) +
                        (galaxusContext?.products?.length || 0),
        validationScore: internetContext.contactValidation?.confidenceScore || 0
      },
      
      // Contexte m√©dical
      medicalContext: {
        cabinetName: 'OphtaCare',
        doctor: 'Dr Tabibian',
        location: 'Gen√®ve',
        specialty: 'Ophtalmologie',
        userRole: 'Responsable Administratif'
      }
    };
    
    return enriched;
  }

  private evaluateDataQualityEnhanced(contextData: any, analysis: any, actionAnalysis: any): any {
    const quality = {
      sufficient: false,
      score: 0,
      details: {},
      recommendations: []
    };
    
    // Scoring bas√© sur la richesse des donn√©es
    const dataPoints = {
      meetings: contextData.meetings.length,
      documents: contextData.documents.length,
      todos: contextData.todos.length,
      participants: contextData.participants.length,
      chunks: contextData.chunks.length,
      galaxusProducts: contextData.galaxusProducts.length
    };
    
    // Calcul du score de qualit√©
    Object.entries(dataPoints).forEach(([type, count]) => {
      if (count > 0) quality.score += 20;
      if (count > 3) quality.score += 10;
      if (count > 8) quality.score += 10;
    });
    
    // Bonus pour correspondance avec analyse
    if (contextData.hasEmbeddingContext) quality.score += 30;
    if (contextData.hasGalaxusProducts) quality.score += 25;
    if (contextData.targetedExtracts?.sections?.length > 0) quality.score += 20;
    if (contextData.fuzzyMatches?.length > 0) quality.score += 15;
    
    // √âvaluation sp√©ciale pour actions
    if (actionAnalysis.isAction) {
      quality.sufficient = true; // Actions n√©cessitent moins de contexte
      quality.score += 50;
    } else {
      quality.sufficient = quality.score >= 60; // Seuil pour questions g√©n√©rales
    }
    
    quality.details = dataPoints;
    
    if (!quality.sufficient) {
      quality.recommendations = [
        'Pr√©ciser le contexte temporel (r√©cent, cette semaine, etc.)',
        'Mentionner des noms de personnes ou entit√©s sp√©cifiques',
        'Utiliser des termes li√©s au cabinet m√©dical'
      ];
    }
    
    return quality;
  }

  private validateMedicalContext(query: string, contextData: any, analysis: any): any {
    const validation = {
      isRelevant: true,
      needsClarification: false,
      context: 'medical_administrative',
      suggestions: []
    };
    
    const lowerQuery = query.toLowerCase();
    
    // V√©rification du contexte m√©dical/administratif
    const medicalTerms = ['patient', 'consultation', 'traitement', 'm√©dical', 'cabinet', 'ophtalmologie', 'docteur'];
    const adminTerms = ['t√¢che', 'planning', 'gestion', 'organisation', 'administratif', 'r√©union'];
    const ophtalmoTerms = ['ophtacare', 'tabibian', 'gen√®ve', 'fischer', 'dupixent'];
    
    const hasMedicalContext = medicalTerms.some(term => lowerQuery.includes(term));
    const hasAdminContext = adminTerms.some(term => lowerQuery.includes(term));
    const hasOphtalmoContext = ophtalmoTerms.some(term => lowerQuery.includes(term));
    
    // Demande de clarification si contexte trop g√©n√©ral
    if (!hasMedicalContext && !hasAdminContext && !hasOphtalmoContext && 
        contextData.searchQuality.totalDataPoints < 3) {
      validation.needsClarification = true;
      validation.suggestions = [
        'Pr√©ciser le contexte du cabinet OphtaCare',
        'Mentionner s\'il s\'agit d\'une question administrative ou m√©dicale',
        'Indiquer des noms de patients, collaborateurs ou √©quipements sp√©cifiques'
      ];
    }
    
    return validation;
  }

  private generateClarificationRequest(originalQuery: string, analysis: any, dataQuality: any, contextValidation: any): string {
    return `Je voudrais vous aider au mieux avec votre demande : "${originalQuery}"

**Pour vous fournir une r√©ponse pr√©cise, j'aurais besoin de plus de contexte :**

${contextValidation.suggestions.map((s: string) => `‚Ä¢ ${s}`).join('\n')}

**Donn√©es disponibles dans OphtaCare :**
‚Ä¢ ${dataQuality.details.meetings} r√©unions r√©centes
‚Ä¢ ${dataQuality.details.documents} documents
‚Ä¢ ${dataQuality.details.todos} t√¢ches en cours
‚Ä¢ ${dataQuality.details.participants} participants/collaborateurs

**Suggestions pour affiner votre demande :**
${dataQuality.recommendations.map((r: string) => `‚Ä¢ ${r}`).join('\n')}

Pouvez-vous reformuler votre question en pr√©cisant le contexte administratif ou m√©dical du cabinet OphtaCare ?`;
  }

  private async generateEnrichedResponse(
    originalQuery: string,
    conversationHistory: any[],
    contextData: any,
    analysis: any,
    actionAnalysis: any,
    contextValidation: any
  ): Promise<string> {
    const hasRichContext = contextData.searchQuality.totalDataPoints > 5;

    let systemPrompt = `Tu es l'assistant IA sp√©cialis√© OphtaCare pour le cabinet du Dr Tabibian √† Gen√®ve.

MISSION PRINCIPALE :
- Aider l'√©quipe administrative avec les t√¢ches quotidiennes
- G√©rer et cr√©er des t√¢ches efficacement
- Fournir des informations pr√©cises bas√©es sur les donn√©es internes
- Ne JAMAIS inventer d'informations

SP√âCIALISATION T√ÇCHES :
- Cr√©ation, consultation et gestion des t√¢ches
- Suivi des t√¢ches en cours et assignations
- Propositions d'actions concr√®tes

R√àGLES ABSOLUES :
1. Pr√©cision et fiabilit√© des informations
2. Pas d'invention de donn√©es
3. Focus sur l'aide pratique et concr√®te
4. Contexte m√©dical toujours respect√©

STYLE : Professionnel, pr√©cis, orient√© action.`;

    const userMessage = `DEMANDE ADMINISTRATIVE ENRICHIE AVEC VALIDATION : ${originalQuery}

${hasRichContext ? `
CONTEXTE INTERNE ULTRA-ENRICHI :

üìã R√âUNIONS R√âCENTES (${contextData.meetings.length}) :
${contextData.meetings.slice(0, 3).map((m: any) => `‚Ä¢ "${m.title}" - ${(m.summary || m.transcript || '').substring(0, 200)}...`).join('\n')}

üìÅ DOCUMENTS PERTINENTS (${contextData.documents.length}) :
${contextData.documents.slice(0, 3).map((d: any) => `‚Ä¢ "${d.ai_generated_name || d.original_name}" - ${(d.ai_summary || d.extracted_text || '').substring(0, 150)}...`).join('\n')}

‚úÖ T√ÇCHES EN COURS (${contextData.todos.length}) :
${contextData.todos.slice(0, 5).map((t: any) => `‚Ä¢ [${t.status}] ${t.description}${t.assigned_to ? ` (${t.assigned_to})` : ''}${t.due_date ? ` - √âch√©ance: ${new Date(t.due_date).toLocaleDateString()}` : ''}`).join('\n')}

üë• PARTICIPANTS/COLLABORATEURS (${contextData.participants.length}) :
${contextData.participants.slice(0, 8).map((p: any) => `‚Ä¢ ${p.name} (${p.email})`).join('\n')}

üîç EXTRAITS S√âMANTIQUES PERTINENTS (${contextData.chunks.length}) :
${contextData.chunks.slice(0, 4).map((c: any, i: number) => `${i+1}. [Score: ${c.similarity?.toFixed(3)}] ${(c.chunk_text || '').substring(0, 200)}...`).join('\n')}

${contextData.hasGalaxusProducts ? `
üõí PRODUITS GALAXUS ${contextData.hasValidatedGalaxusLinks ? 'VALID√âS' : 'TROUV√âS'} (${contextData.galaxusProducts.length}) :
${contextData.galaxusRecommendations.substring(0, 500)}...
` : ''}

${contextData.targetedExtracts ? `
üéØ EXTRACTIONS CIBL√âES pour "${contextData.targetedExtracts.entity}" :
${contextData.targetedExtracts.sections.slice(0, 2).map((s: string) => `‚Ä¢ ${s.substring(0, 150)}...`).join('\n')}
` : ''}

${contextData.fuzzyMatches?.length > 0 ? `
üîÑ CORRESPONDANCES APPROXIMATIVES :
${contextData.fuzzyMatches.slice(0, 2).map((fm: any) => `‚Ä¢ "${fm.originalTerm}" ‚Üí ${fm.matches.length} r√©sultats`).join('\n')}
` : ''}

${contextData.hasValidatedContacts ? `
üìû COORDONN√âES VALID√âES (Score: ${contextData.contactConfidenceScore}%) :
${contextData.validatedContacts.slice(0, 3).map((c: any) => `‚Ä¢ ${c.type}: ${c.value || (c.name + ' - ' + c.url)}`).join('\n')}
` : ''}
` : 'Contexte limit√© - utiliser les donn√©es disponibles.'}

${contextData.hasInternetContext ? `
üåê INFORMATIONS COMPL√âMENTAIRES VALID√âES :
${(contextData.internetContent || '').substring(0, 300)}...
` : ''}

VALIDATION CRITIQUE ACTIV√âE :
- Score confiance coordonn√©es: ${contextData.contactConfidenceScore}%
- Liens Galaxus valid√©s: ${contextData.hasValidatedGalaxusLinks ? 'OUI' : 'NON'}
- Coordonn√©es v√©rifi√©es: ${contextData.hasValidatedContacts ? 'OUI' : 'NON'}

Utilise TOUTES ces informations valid√©es pour fournir la r√©ponse la plus compl√®te et pr√©cise possible. 
LIENS CLIQUABLES OBLIGATOIRES format [nom](url) - URLs compl√®tes v√©rifi√©es uniquement.
Coordonn√©es SEULEMENT si score confiance > 50% ET trouv√©es dans sources.
TOUJOURS mentionner d'autres fournisseurs pour produits.
PRIORIT√â: Aucune information non v√©rifi√©e.`;

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.openaiApiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userMessage }
          ],
          temperature: 0.7,
          max_tokens: 1800, // Plus de tokens pour r√©ponses enrichies avec Galaxus
        }),
      });

      const data = await response.json();
      let finalResponse = data.choices[0]?.message?.content || 
                         'D√©sol√©, je ne peux pas traiter votre demande pour le moment.';
      
      // Nettoyage final
      finalResponse = finalResponse.replace(/\s*CONTEXT_PARTICIPANTS:.*$/gi, '').trim();
      
      return finalResponse;
      
    } catch (error) {
      console.error('[SYNTHESIS] Error generating enriched response:', error);
      
      // Fallback enrichi avec action si applicable
      if (actionAnalysis.isAction && actionAnalysis.action.type === 'create') {
        const taskData = actionAnalysis.action.details.taskCreation.data;
        const actionSyntax = `[ACTION_TACHE: TYPE=CREATE, description="${taskData.description}", assigned_to="${taskData.assigned_to || ''}", due_date="${taskData.due_date || ''}"]`;
        
        return `Je vais cr√©er cette t√¢che selon votre demande :

**Nouvelle t√¢che administrative :**
- Description : ${taskData.description}
${taskData.assigned_to ? `- Assign√©e √† : ${taskData.assigned_to}` : ''}
${taskData.due_date ? `- √âch√©ance : ${taskData.due_date}` : ''}
- Contexte : Gestion administrative cabinet OphtaCare

${actionSyntax}

Cette t√¢che sera int√©gr√©e dans le syst√®me de gestion du cabinet.`;
      }
      
      return `Je rencontre un probl√®me technique temporaire. Les donn√©es sont disponibles (${contextData.searchQuality.totalDataPoints} √©l√©ments trouv√©s), mais je ne peux pas g√©n√©rer la r√©ponse compl√®te actuellement. 

Pouvez-vous reformuler votre demande ou r√©essayer dans quelques instants ?`;
    }
  }
}
